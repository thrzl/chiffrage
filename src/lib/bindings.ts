
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async isFirstOpen() : Promise<boolean> {
    return await TAURI_INVOKE("is_first_open");
},
async fetchKeys() : Promise<KeyMetadata[]> {
    return await TAURI_INVOKE("fetch_keys");
},
async loadVault() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_vault") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createVault(password: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_vault", { password }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vaultExists() : Promise<boolean> {
    return await TAURI_INVOKE("vault_exists");
},
async generateKeypair(name: string, format: KeyFormat | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_keypair", { name, format }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async encryptFile(recipient: EncryptionMethod, reader: TAURI_CHANNEL<FileOperationProgress>, files: string[], armor: boolean | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("encrypt_file", { recipient, reader, files, armor }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async decryptFile(privateKey: string, reader: TAURI_CHANNEL<FileOperationProgress>, files: string[], method: DecryptionMethod) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("decrypt_file", { privateKey, reader, files, method }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async generatePassphrase() : Promise<string> {
    return await TAURI_INVOKE("generate_passphrase");
},
async exportKey(key: string, path: string, mode: KeyExportMode) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_key", { key, path, mode }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importKey(name: string, path: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_key", { name, path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteKey(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_key", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchKey(name: string) : Promise<KeyMetadata | null> {
    return await TAURI_INVOKE("fetch_key", { name });
},
async authenticate() : Promise<Result<VaultStatusUpdate, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("authenticate") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vaultUnlocked() : Promise<boolean> {
    return await TAURI_INVOKE("vault_unlocked");
},
async importKeyText(name: string, keyContent: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_key_text", { name, keyContent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * returns `true` if the key is private
 */
async checkKeyfileType(path: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_keyfile_type", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async lockVault() : Promise<Result<null, null>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("lock_vault") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * command to regenerate the public keys of all identities.
 */
async regeneratePublicIdentities() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("regenerate_public_identities") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validateKeyFile(path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_key_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validateKeyText(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_key_text", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async armorCheckText(text: string) : Promise<boolean> {
    return await TAURI_INVOKE("armor_check_text", { text });
},
async decryptText(privateKey: string, text: string, method: DecryptionMethod) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("decrypt_text", { privateKey, text, method }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async encryptText(recipient: EncryptionMethod, text: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("encrypt_text", { recipient, text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downgradeHybridPublicKey(publicKey: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("downgrade_hybrid_public_key", { publicKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
vaultStatusUpdate: VaultStatusUpdate
}>({
vaultStatusUpdate: "vault-status-update"
})

/** user-defined constants **/



/** user-defined types **/

export type DecryptionMethod = "X25519" | "Scrypt"
/**
 * a type storing an XChaCha20Poly1305 `ciphertext` and `nonce`. both are of type `Vec<u8>`.
 */
export type EncryptedSecret = { nonce: number[]; ciphertext: number[] }
export type EncryptionMethod = string[] | string
export type FileOperationProgress = { read_bytes: number; total_bytes: number; current_file: string }
export type KeyExportMode = "PostQuantum" | "X25519"
export type KeyFormat = "X25519" | "PostQuantum"
/**
 * representation of a key object. id is a cuid2
 */
export type KeyMetadata = { id: string; name: string; key_type: KeyType; date_created: SystemTime; contents: KeyPair }
/**
 * an object storing the actual key contents.
 * 
 * `public` contains the public key in plaintext
 * 
 * `private` is `Option<EncryptedSecret>`, being an object containing a `nonce` and `ciphertext` (both `Vec<u8>`)
 */
export type KeyPair = { public: string; private: EncryptedSecret | null }
export type KeyType = "Public" | "Private"
export type SystemTime = { duration_since_epoch: number; duration_since_unix_epoch: number }
export type VaultStatusUpdate = "unlocked" | "verificationFail" | "authenticationCancel" | "locked"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
